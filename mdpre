#!/usr/bin/env python3
"""
mdpre - Preprocesses a file into Markdown

Use -h for help
"""

import os
import sys
import csv
import shutil
import zipfile
import io
import subprocess
import platform
import math

# import StringIO
import re
import datetime
from pathlib import Path
from enum import Enum
import calendar
import tempfile

mdpre_level = "1.1.2"
mdpre_date = "19 August, 2025"
banner = "mdpre Markdown Preprocessor v" + mdpre_level + " (" + mdpre_date + ")"


def log(textToLog):
    logfileHandle.write(textToLog + "\n")

def checkFileDescriptorExists(fdNumber):
    try:
        r = os.stat(fdNumber)
        return True
    except:
        return False

# Ensure file descriptor 3 exists so any explicitly opened file doesn't
# try to use it.
if checkFileDescriptorExists(3) is False:
    # Force creation of a temporary file with file descriptor 3
    t = tempfile.TemporaryFile()

monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December",
]


def log_status(p_line):
    log("-" * len(banner))
    log(p_line)
    log("-" * len(banner) + "\n")


g_output = None
g_wrapInCSV = False

CSV_colaligns = []
CSV_colwidths = []
CSV_flowLines = 0
CSV_flowGutterCells = 0

in_csv = False

cal_date = (0, 0, 2)
in_cal = False

# Returns an array of image etc names
def getResourceNames(line):
    resourceNames = []
    
    for (_, name, *_) in re.findall(graphicRegex, line):
        resourceNames.append(name)
    
    for (_, name, *_) in re.findall(videoRegex, line):
        resourceNames.append(name)
    
    for (_, name, *_) in re.findall(clickableGraphicRegex, line):
        resourceNames.append(name)
    
    for (_, name, *_) in re.findall(audioRegex, line):
        resourceNames.append(name)
    
    return resourceNames

# Find index of variable in variable list. -1 means "not found"
def find_variable(targetVar):
    global vars
    foundVar = -1
    cursor = 0
    for var in vars:
        if var[0] == targetVar:
            varRecord = var
            foundVar = cursor
            break
        cursor += 1
    return foundVar

# Set a variable for the first time - or update it if it already exists
def setOrUpdateVariable(varName, varValue):
	global vars
	for var in parse_def(varName + " " + varValue):
		var_index = find_variable(var[0])
		if var_index > -1:
			# Replace the variable with its new definition
			vars[var_index] = var
		else:
			 # Add the variable as it's new
			vars.append(var)

class OutputType(Enum):
    """preparation for later usage. support e.g. other outputs like MMD or ADOC"""

    MD = 1

def handle_CSVrule(rules, spec):
    specWords = spec.strip().split(" ")
    if len(specWords) == 1:
        if specWords[0] == "delete":
            rules = []
        else:
            rules.append(spec)
    else:
        rules.append(spec)

    return rules

def handle_CSVflow(spec):
    goodSpec = True
    specWords = spec.strip().split(" ")

    try:
        flowLines = int(specWords[0])
    except:
        log(f"ERROR: =csvflow requires an integer. \"{spec}\" specified")
        goodSpec = False

    if len(specWords) == 1:
        flowGutterCells = 0
    else:
        try:
            flowGutterCells = int(specWords[-1])
        except:
            log(f"ERROR: =csvflow requires an integer for the second parameter. \"{specWords[-1]}\" specified")
            goodSpec = False

    if goodSpec:
        return flowLines, flowGutterCells
    else:
        # Return the previous values
        return CSV_flowLines, CSV_flowGutterCells


class Output(object):
    NL = "\n"
    output = OutputType.MD

    def __init__(self, p_toFile):
        self.toFile = None
        if hasattr(p_toFile, "write"):
            self.toFile = p_toFile
            log(f"- opened {p_toFile.name} for writing")
        else:
            log(f"ERROR: g_output could not find an open file {p_toFile}")
            exit_script(g_output, -101)

    def close(self):
        self.toFile.close()

    def write(self, p_text):
        if self.output == OutputType.MD:
            self.toFile.write(f"{p_text}{self.NL}")

    def write_line(self, p_text):
        self.write(f"{p_text}{self.NL}")

    def formatCSV(self, CSV_lines, colalign, colwidth, rules, flowLines, flowGutterCells):
        if csvDialect == "":
            CSV_reader = csv.reader(CSV_lines)
        else:
            CSV_reader = csv.reader(CSV_lines, csvDialect)

        # Find out how many columns and prime CSV_lines
        rowCount = 0
        columnCount = 0

        CSV_lines = []
        for rowNumber, row in enumerate(CSV_reader):
            columnCount = max(columnCount, len(row))

            rowCount += 1 

            CSV_lines.append(row)

        # Potentially flow the input CSV into a wider table
        if flowLines > 0:
            # The first row is treated as a title row - perhaps to be replicated
            dataRowCount = rowCount - 1
        
            # Calculate how many times the cells need to be replicated
            flowings = math.ceil(dataRowCount / flowLines)

            # Create a list with gutter cells in
            gutterCells = [" "] * flowGutterCells


            # Extend each pre-existing line to the maximum length,
            # including the title line, adding any gutter cells.
            for lineNumber in range(len(CSV_lines)):
                CSV_lines[lineNumber].extend([" "] * (columnCount - len(CSV_lines[lineNumber])))
                CSV_lines[lineNumber].extend(gutterCells)
            
            titleLine = CSV_lines[0]

            # Replicate the cells in the title row the right number of times
            titleLine *= flowings
                        
            # Operate on the data lines
            dataLines = CSV_lines[1:]
            # Flow the data lines - if needed
            if flowings > 1:
                for lineNumber, CSV_line in enumerate(dataLines):
                    targetLine = lineNumber % flowLines
                    if lineNumber >= flowLines:
                        dataLines[targetLine].extend(dataLines[lineNumber])

            # Get rid of surplus data lines - now they've been appended
            if len(dataLines) >= flowLines:
                dataLines = dataLines[:flowLines]

            # Complete padding
            padCells = [" "] * columnCount
            padCells.extend(gutterCells)
            
            for lineNumber, dataLine in enumerate(dataLines):
                if len(dataLine) < (columnCount + flowGutterCells) * flowings:
                    dataLines[lineNumber].extend(padCells)
                #dataLines[lineNumber].extend(gutterCells)
            
            # Adjust column count - due to flowing and gutters
            columnCount = (columnCount + flowGutterCells) * flowings - flowGutterCells
            
            # Reconstruct CSV lines from title and reformatted data            
            CSV_lines = []
            CSV_lines.append(titleLine)
            CSV_lines.extend(dataLines)
            
            if flowGutterCells > 0:
                for lineNumber, _ in enumerate(CSV_lines):
                    CSV_lines[lineNumber] = CSV_lines[lineNumber][:-flowGutterCells]

        # Prime column width and alignment extenders
        colWidthExtender = 1
        colAlignExtender = "l"
        
        # Expand colalign shorthand
        colalign2 = []
        lastColAlign = len(colalign) - 1
        for caNumber, ca in enumerate(colalign):
            if ca.find("x") > -1:
                alignment, replication = ca.split("x")
                
                if (replication == "*") and (caNumber == lastColAlign):
                    replication = 1
                    colAlignExtender = alignment
                else:
                    replication = int(replication)
            else:
                alignment, replication = ca, 1

            # Extend list by the replication factor
            colalign2.extend([alignment] * replication)

        colalign = colalign2

        # Extend colalign to cover all columns - now we know how many there are
        colalign.extend([colAlignExtender]* (columnCount - len(colalign)))
           
        # Expand colwidth shorthand
        colwidth2 = []
        lastColWidth = len(colwidth) - 1
        for cwNumber, cw in enumerate(colwidth):
            if cw.find("x") > -1:
                width, replication = cw.split("x")

                if (replication == "*") and (cwNumber == lastColWidth):
                    replication = 1
                    colWidthExtender = width
                else:
                    replication = int(replication)
            else:
                width, replication = cw, 1

            # Extend list by the replication factor
            colwidth2.extend([int(width)] * replication)

        colwidth = colwidth2

        # Extend colwidth to cover all columns - now we know how many there are
        colwidth.extend([int(colWidthExtender)] * (columnCount - len(colwidth)))
           
        # Now print the table
        for rowNumber0, row in enumerate(CSV_lines):
            # Human-understandable row number (1-indexed)
            rowNumber = rowNumber0 + 1

            row_text = "|"
            for col_index, col_text in enumerate(row):
                # Human-understandable column number (1-indexed)
                columnNumber = col_index + 1

                # Human-understandable variable containing original cell text
                cellText = col_text

                spanClass = ""

                # For each cell first apply any rowspan class
                if (col_index == 0) & (col_text.startswith("=rowspan ")):
                    rowspan2 = col_text.split("!!XYZZY!!")
                    spanClass = rowspan2[0][9:]
                    col_text = rowspan2[1][1:-1]
                
                # Apply any rules to the cell
                for rule in rules:
                    # Following splits at white space of any kind and only returns 2 items
                    # (white space of any length)
                    (ruleClass, ruleCondition) = tuple(rule.split(None, 1))

                    try:
                        ruleMet =eval(ruleCondition)
                    except:
                        ruleMet = False
                    
                    if ruleMet:
                        spanClass = ruleClass
                
                if spanClass == "":
                    cell_prefix = ""
                    cell_suffix = ""
                else:
                    cell_prefix = "<span class=\"" + spanClass +"\">"
                    cell_suffix = "</span>"
                      
                row_text = row_text + cell_prefix + col_text + cell_suffix + "|"
            self.write(row_text)

            if rowNumber0 == 0:
                # Insert line under title line
                titleUnderline = "|"
                
                for col_index in range(columnCount):
                    # Handle column width with dashes - for md2pptx
                    # (and probably no other tool)
                    dashes = "-" * (colwidth[col_index])

                    # Add in the column alignment character - as appropriate                    
                    if colalign[col_index] == "r":
                        titleUnderline = titleUnderline + dashes + ":|"
                    
                    elif colalign[col_index] == "c":
                        titleUnderline = titleUnderline + ":" + dashes + ":|"
                    
                    elif colalign[col_index] == "l":
                        titleUnderline = titleUnderline + ":" + dashes + "|"
                    
                    else:
                        titleUnderline = titleUnderline + dashes + "|"

                self.write(titleUnderline)
        return

    def formatCalendar(self, cal_lines, cal_date, cal_spans, cal_keys, cal_notes):
        # Get a calendar month in a 2-dimensional array
        cal_year, cal_month, cal_cellHeight = cal_date
        c = calendar.TextCalendar(calendar.MONDAY)
        daysAndNumbers = c.formatmonth(cal_year, cal_month).split("\n")[1: -1]
        

        # Process the rows into day names and actual day numbers
        weeks = []

        for rowNumber, row in enumerate(daysAndNumbers):
            rawCells = []
            row = row.ljust(21)
            for d in range(7):
                rawCells.append(str(row[d * 3 : d * 3 +3]).lstrip().rstrip())

            if rowNumber == 0:
                dayNames = rawCells
            else:
                weeks.append(rawCells)

        # Write month line
        self.write("|" + monthNames[cal_month - 1] + " " + str(cal_year) + "|||||||")
        
        # Write the table heading
        self.write(("|:-:") * 7 + "|")

        dayLine = "|"
        for dayName in dayNames:
            dayLine = dayLine + "**" + dayName + "**|"

        self.write(dayLine)

        # Write the remaining lines
        for week in weeks:
            weekLine = "|"
            for day in week:
                # Figure out if day has a note
                if day in cal_notes.keys():
                    dayNote = "<br/>" + cal_notes[day]
                    cellLines = len(dayNote.split("<br/>"))
                else:
                    dayNote = ""
                    cellLines = 1

                # Compose day Markdown / HTML
                if day in cal_spans.keys():
                    formattedDay = (
                        "<span class='"
                        + cal_spans[day]
                        + "'>"
                        + day
                        + "</span>"
                        + dayNote
                    )
                else:
                    formattedDay = day + dayNote

                # Make blank cell appear
                if formattedDay == "":
                    formattedDay = "&nbsp;"
                    
                # Vertically pad
                formattedDay = formattedDay + "<br/>" * (cal_cellHeight - cellLines)

                # Add day cell to week line
                weekLine = weekLine + formattedDay + "|"

            # Write week line
            self.write(weekLine)

        # Write any descriptions
        self.write("")
        for key in cal_keys.keys():
            self.write("* <span class='" + key + "'>&nbsp;</span>" + cal_keys[key])
        self.write("")

    # Print Table Of Contents down to maximum level
    def printTableOfContents(self, minLevel, maxLevel, heading, toc):

        self.write_line(heading)
        for tocEntryLevel, tocEntryText in toc:
            if (tocEntryLevel >= minLevel) & (tocEntryLevel <= maxLevel):
                self.write(
                    ("\t" * (tocEntryLevel - minLevel))
                    + "* ["
                    + tocEntryText
                    + "](#"
                    + makeLink(tocEntryText)
                    + ")",
                )

    def handle_adjustGraphics(self, line):
        adjustedLine = ""
        splitStart = line.split("![")
        fragment = 0
        for s in splitStart:
            if fragment == 0:
                # Before first ![
                adjustedLine = s + "!["
            else:
                # At first or subsequent ![
                endLabelPos = s.find("](")
                beginGraphicPos = endLabelPos + 2
                adjustedLine += s[:beginGraphicPos]
                endGraphicPos = s.find(")")

                # Extract original graphic name, including subdirs
                graphic = s[beginGraphicPos:endGraphicPos]

                # Adjust graphic so it's in the assets subfolder
                lastSlash = graphic.rfind("/")
                if lastSlash == -1:
                    adjustedGraphic = "assets/" + graphic
                else:
                    adjustedGraphic = "assets/" + graphic[lastSlash + 1 :]

                adjustedLine = (
                    adjustedLine + adjustedGraphic + ")" + s[endGraphicPos + 1 :]
                )

                # Copy the file into the text bundle
                shutil.copy(graphic, realpath + "/" + adjustedGraphic)
            fragment += 1
        if wantVerbose is True:
            log("Adjusting >>" + adjustedLine + "<<<\n")

        self.write(adjustedLine)

        return


##########################
# Class to control loops #
##########################

class LoopController:

    def __init__(self, loopType, parent, loopVarName, loopVarValues, loopValue = "", children = []):
        self.loopType = loopType
        self.parent = parent
        self.loopVarName = loopVarName
        self.loopVarValues = loopVarValues
        self.children = children
        self.lineValue = loopValue
        self.endForEncountered = False
        self.currentIndex = -1
        self.valueCount = len(loopVarValues)


####################
# Helper Functions #
####################

def intTryParse(value):
    try:
        return int(value), True
    except ValueError:
        return value, False


def parse_colalign(colString, p_separator = r"\s+"):
    cs = colString.rstrip().lstrip()

    return re.split(p_separator, cs)


def parse_colwidth(colString, p_separator = r"\s+"):
    cs = colString.rstrip().lstrip()
    colwidths = re.split(p_separator, cs)
    colwidthInt = []
    for c in colwidths:
        colwidthInt.append(c)

    return colwidthInt


def parse_calstart(calString, p_separator = r"\s+"):
    d = calString.rstrip().lstrip()
    ym = re.split(p_separator, d)

    if len(ym) < 3:
        cal_cellHeight = 2
    else:
        cal_cellHeight = int(ym[2])

    return (int(ym[0]), int(ym[1]), cal_cellHeight)


def parse_caldays(spanString, cal_spans, p_separator = r"\s+"):
    sp = spanString.rstrip().lstrip()
    words = re.split(p_separator, sp)

    for w in range(len(words)):
        if w == 0:
            # Pick up class name
            spanClass = words[w]
        else:
            # Pick up dates
            dayRange = words[w].split("-")
            if len(dayRange) == 1:
                # Single date specified
                dayNumber = dayRange[0]
                cal_spans[dayNumber] = spanClass
            else:
                # Range of dates specified
                for dayNumber in range(int(dayRange[0]), int(dayRange[1]) + 1):
                    cal_spans[str(dayNumber)] = spanClass

    return cal_spans


def parse_calkeys(keyString, cal_keys):
    keyString = keyString.rstrip().lstrip()
    spacePos = keyString.find(" ")
    keyName = keyString[:spacePos]
    keyValue = keyString[spacePos + 1 :]
    cal_keys[keyName] = keyValue

    return cal_keys


def parse_calnote(noteString, cal_notes):
    noteString = noteString.rstrip().lstrip()

    # Pick up single date or range
    spacePos = noteString.find(" ")
    noteDays = noteString[:spacePos]

    # Pick up the note string
    noteText = noteString[spacePos + 1 :]

    # Pick up dates
    dayRange = noteDays.split("-")
    if len(dayRange) == 1:
        # Single date specified
        dayNumber = dayRange[0]
        cal_notes[dayNumber] = noteText
    else:
        # Range of dates specified
        for dayNumber in range(int(dayRange[0]), int(dayRange[1]) + 1):
            cal_notes[str(dayNumber)] = noteText

    return cal_notes


# Handle =def - which might return more than one variable
def parse_def(defString):
    defString = defString.rstrip()
    spacePos = defString.find(" ")
    varNameString = defString[:spacePos]
    residue = defString[spacePos + 1 :]
    if spacePos == -1:
        # Is a flag
        varType = "F"
        varValue = ""
        varNameString = defString

        return [[varNameString, varType, varValue]]
    else:
        # Is a value or values
        varType = "T"
        if (residue[0] == "`") & (residue[-1] == "`"):
            return handle_exec(varNameString, residue[1:-1])
        else:
            varValue = residue
            return [[varNameString, varType, varValue]]



def parse_inc(line):
    global vars
    targetVar = line[5:-1].lstrip()
    foundVar = find_variable(targetVar)
    if foundVar > -1:
        varRecord = vars[foundVar]
        if varRecord[1] != "T":
            log(
                "Variable " + targetVar + " is a flag. Cannot be incremented.\n"
            )
        else:
            intVal, OK = intTryParse(varRecord[2])
            if OK is False:
                log(
                    "Variable "
                    + targetVar
                    + " is not an integer. Cannot be incremented.\n"
                )
            else:
                vars[foundVar] = [targetVar, "T", str(intVal + 1)]

    else:
        log(
            "Variable " + targetVar + " not found. Cannot be incremented.\n"
        )


def parse_dec(line):
    global vars
    targetVar = line[5:-1].lstrip()
    foundVar = find_variable(targetVar)
    if foundVar > -1:
        varRecord = vars[foundVar]
        if varRecord[1] != "T":
            log(
                "Variable " + targetVar + " is a flag. Cannot be decremented.\n"
            )
        else:
            intVal, OK = intTryParse(varRecord[2])
            if OK is False:
                log(
                    "Variable "
                    + targetVar
                    + " is not an integer. Cannot be decremented.\n"
                )
            else:
                vars[foundVar] = [targetVar, "T", str(intVal - 1)]

    else:
        log(
            "Variable " + targetVar + " not found. Cannot be decremented.\n"
        )

def handle_exec(nameString, commandString):
    outputVariables = []
    
    varNames = nameString.split(",")
    
    # Always have a stdout variable
    stdoutVarname = varNames[0]

    # Run the command string
    cp = subprocess.run(commandString, capture_output = True, shell = True)

    # Put stdout into a variable
    outputVariables.append([stdoutVarname, "T", cp.stdout.decode('utf-8').rstrip('\n')])
        
    if len(varNames) == 2:
        # Have a stderr variable
        stderrVarname = varNames[1]
        
        # Put stderr into a variable    
        outputVariables.append([stderrVarname, "T", cp.stderr.decode('utf-8').rstrip('\n')])
        
    return outputVariables


# =ifempty encountered
def handle_ifempty(ifemptyString):
    global ifStack, vars
    verbosity = ""

    for varName, varType, varValue in vars:
        if varName == ifemptyString:
            # Variable is defined
            if varValue == "":
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifempty:true:" + ifemptyString + "-->"

                ifStack.append(True)
            else:
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifempty:false:" + ifemptyString + "-->"

                ifStack.append(False)

            return verbosity

    # Variable is undefined
    ifStack.append(False)

    if wantVerbose is True:
        verbosity = "<!--mdpre-ifempty:undefined:" + ifemptyString + "-->"

    return verbosity

# =ifnotempty or =ifnempty encountered
def handle_ifnotempty(ifnotEmptyString):
    global ifStack, vars
    verbosity = ""

    for varName, varType, varValue in vars:
        if varName == ifnotEmptyString:
            # Variable is defined
            if varValue != "":
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifnotempty:true:" + ifnotEmptyString + "-->"

                ifStack.append(True)
            else:
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifnotempty:false:" + ifnotEmptyString + "-->"

                ifStack.append(False)

            return verbosity

    # Variable is undefined
    ifStack.append(False)

    if wantVerbose is True:
        verbosity = "<!--mdpre-ifnotempty:undefined:" + ifnotEmptyString + "-->"

    return verbosity

# =ifmatch encountered
def handle_ifmatch(ifmatchString):
    global ifStack, vars
    verbosity = ""
    
    spacePos = ifmatchString.find(" ")
    expressionPos = spacePos + 1
    ifmatchVariable = ifmatchString[:spacePos]
    ifmatchExpression = ifmatchString[expressionPos:]
    ifmatchRE = re.compile(ifmatchExpression)

    for varName, varType, varValue in vars:
        if varName == ifmatchVariable:
            # Variable is defined
            if ifmatchRE.match(varValue) is not None:
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifmatch:true:" + ifmatchString + "-->"

                ifStack.append(True)
            else:
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifmatch:false:" + ifmatchString + "-->"

                ifStack.append(False)

            return verbosity

    # Variable is undefined
    ifStack.append(False)

    if wantVerbose is True:
        verbosity = "<!--mdpre-ifmatch:undefined:" + ifmatchString + "-->"

    return verbosity


# =ifnotmatch or =ifnmatch encountered
def handle_ifnotmatch(ifnmatchString):
    global ifStack, vars
    verbosity = ""

    spacePos = ifnmatchString.find(" ")
    expressionPos = spacePos + 1
    ifnmatchVariable = ifnmatchString[:spacePos]
    ifnmatchExpression = ifnmatchString[expressionPos:]
    ifnmatchRE = re.compile(ifnmatchExpression)

    for varName, varType, varValue in vars:
        if varName == ifnmatchVariable:
            # Variable is defined
            if ifnmatchRE.match(varValue) is None:
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifnotmatch:true:" + ifnmatchString + "-->"

                ifStack.append(True)
            else:
                if wantVerbose is True:
                    verbosity = "<!--mdpre-ifnotmatch:false:" + ifnmatchString + "-->"

                ifStack.append(False)

            return verbosity

    # Variable is undefined
    ifStack.append(False)

    if wantVerbose is True:
        verbosity = "<!--mdpre-ifnotmatch:undefined:" + ifnmatchString + "-->"

    return verbosity


# =ifdef encountered
def handle_ifdef(ifdefString):
    global ifStack, vars
    verbosity = ""

    for varName, varType, varValue in vars:
        if varName == ifdefString:
            # Variable is defined
            if wantVerbose is True:
                verbosity = "<!--mdpre-ifdef:true:" + varName + "-->"

            ifStack.append(True)

            return verbosity

    # Variable is undefined
    ifStack.append(False)

    if wantVerbose is True:
        verbosity = "<!--mdpre-ifdef:false:" + ifdefString + "-->"

    return verbosity


# =ifndef encountered
def handle_ifndef(ifndefString):
    global ifStack, vars
    verbosity = ""

    for varName, varType, varValue in vars:
        if varName == ifndefString:
            # Variable is defined
            if wantVerbose is True:
                verbosity = "<!--mdpre-ifndef:false:" + ifndefString + "-->"

            ifStack.append(False)

            return verbosity

    # Variable is undefined

    ifStack.append(True)

    if wantVerbose is True:
        verbosity = "<!--mdpre-ifndef:true:" + ifndefString + "-->"

    return verbosity


# =endif encountered
def handle_endif():
    global ifStack
    if wantVerbose is True:
        verbosity = "<!--mdpre-endif:-->"
    else:
        verbosity = ""

    if len(ifStack) == 1:
        log(f"Missing 'if' condition encountered.")
    else:        
        try:
            ifStack.pop()
        except:
            log(f"Missing 'if' condition encountered.")


    return verbosity


def handle_undef(name):
    global vars
    for var in vars:
        if var[0] == name:
            vars.remove(var)
            return ["<!--mdpre-undef:found:" + name + "-->"]

    return ["<!--mdpre-undef:notfound:" + name + "-->"]

def handle_for(forArguments):
    global rootLoopController, currentLoopController
    global vars

    ####################
    # Handle arguments #
    ####################
    forArgs=forArguments.split(" ")
    
    # Remove empty members because of multiple spaces
    forArgs = [i for i in forArgs if i]
    
    # Remove optional "="
    forArgs = [i for i in forArgs if i != "="]
    
    loopIsIn = False
    
    # Parse arguments
    argCount = len(forArgs)

    if argCount < 3:
        log(f"Syntax error: {forArguments}\n")
        log("Stopping.")
        sys.exit()

    elif forArgs[1].lower() == "in":
        # for / in variant
        loopVarname = forArgs[0]
        
        # Get remainder of statement after the variable and "in"
        afterIn = forArguments.find(" in ") + 4
        rest = forArguments[afterIn:]

        # ~Use CSV reader to parse the line
        loopValues = csv.reader(io.StringIO(rest), escapechar = "\\", skipinitialspace = True).__next__()

        loopIsIn = True

    elif argCount == 4:
        # for / to - without by
        loopVarname = forArgs[0]

        loopFirst = int(forArgs[1])

        if forArgs[2].lower() != "to":
            log(f"Syntax error: {forArguments}\n")
            log("Stopping.")
            sys.exit()
        
        loopLast = int(forArgs[3])

        loopBy = 1
    else:
        # for / to / by
        loopVarname = forArgs[0]

        loopFirst = int(forArgs[1])

        if forArgs[2].lower() != "to":
            log(f"Syntax error: {forArguments}\n")
            log("Stopping.")
            sys.exit()
        
        loopLast = int(forArgs[3])

        if forArgs[4].lower() != "by":
            log(f"Syntax error: {forArguments}\n")
            log("Stopping.")
            sys.exit()
        

        loopBy = int(forArgs[5])

    # Only use range to make list if not "in" form
    if loopIsIn is False:
    # Make values into a list
        loopLast = loopLast + loopBy
        loopValues = [*range(loopFirst, loopLast, loopBy)]

    ##############################
    # Set up the loop controller #
    ##############################

    # Register this for loop
    loopController = LoopController("for", None, loopVarname, loopValues,"", [])
    if rootLoopController == None:
        # Start the tree of loops
        rootLoopController = loopController
        currentLoopController = loopController
    else:
        if currentLoopController != None:
            # Add loop controller to tree as a child at parent's position
            currentLoopController.children.append(loopController)
            loopController.parent = currentLoopController
            currentLoopController = loopController
    
    # Set the loop variable to its initial value
    setOrUpdateVariable(loopVarname, str(loopValues[0]))

    return "<!--mdpre-for:" + forArguments + "-->"

def _printLoopControllers(loopController, level):
    print("    " * level + "--------------------")
    print("    " * level + "Type: " + loopController.loopType)
    print("    " * level + "Self: " + str(loopController))
    print("    " * level + "Parent: " + str(loopController.parent))
    print("    " * level + "End For: " + str(loopController.endForEncountered))
    print("    " * level + "Variable: " + loopController.loopVarName)
    for value in loopController.loopVarValues:
        print("    " * level + str(value))
    if loopController.loopType == "line":
        print("    " * level + "Line value: " +loopController.lineValue)
    elif loopController.loopType == "include":
        print("    " * level + "Filename: " +loopController.lineValue[9:])
    else:
        print("    " * level + "Children:")
        for child in loopController.children:
            print("    " * level + str(child))
    
    print("    " * level + "--------------------")
    print("\n")

    for child in loopController.children:
        _printLoopControllers(child, level + 1)
    print("\n\n")
    
def printLoopControllers():
    if rootLoopController is not None:
        _printLoopControllers(rootLoopController, 0)
    else:
        print("No loop controllers")

def interpretLoops(input_file2, loopController):
    global vars
    global rootLoopController, currentLoopController
    #printLoopControllers()

    # Loop over the loop variable's values
    for loopVarValue in loopController.loopVarValues:
        # Set the loop variable's current value
        setOrUpdateVariable(loopController.loopVarName, str(loopVarValue))

        # Add the children of this loop controller
        for child in loopController.children:
            if child.loopType == "line":
                line = substitute_variables(child.lineValue)
                input_file2.append(line)
            elif child.loopType == "include":
                line = substitute_variables(child.lineValue)
                include_name = substitute_variables(line[9:].rstrip().lstrip())

                # Check for recursive inclusion
                if include_name in includeStack:
                    log(
                        f"File '{include_name}' recursively included. Stopping."
                    )
                    sys.exit()

                if wantVerbose is True:
                    input_file2.append(
                        "<!--mdpre-embed-start:"
                        + str(embedLevel)
                        + ":"
                        + include_name
                        + "-->"
                    )

                # Not recursive so add include file name to stack
                includeStack.append(include_name)

                try:
                    with open(include_name, "r") as f:
                        stopIt, include_lines = parse_include(f.readlines())
                except:
                    log(f"File {include_name} missing. Terminating.\n")
                    exit()

                for line2 in include_lines:
                    input_file2.append(line2)

                if wantVerbose is True:
                    input_file2.append(
                        "<!--mdpre-embed-stop:"
                        + str(embedLevel)
                        + ":"
                        + include_name
                        + "-->"
                    )

                if stopIt is True:
                    return [stopIt, input_file2, vars]
            else:
                input_file2 = interpretLoops(input_file2, child)
    if loopController == rootLoopController:
        rootLoopController = None
        currentLoopController = None
    return input_file2

def handle_endfor(endforArguments, input_file2):
    global rootLoopController, currentLoopController
    global vars

    loopController = currentLoopController

    # Flag "end for" encountered
    currentLoopController.endForEncountered = True

    # Back to processing parent
    currentLoopController = currentLoopController.parent
    # printLoopControllers()
    
    # If all the way up to root loop controller has met "end for" interpret the loop set
    if rootLoopController.endForEncountered:
        input_file2 = interpretLoops(input_file2, rootLoopController)

    return ["<!--mdpre-endfor:" + endforArguments + "-->", input_file2]
    

def parse_include(input_file):
    global rootLoopController, currentLoopController
    global embedLevel
    global ifStack
    global vars
    
    embedLevel += 1
    input_file2 = []
    for line in input_file:
        if line.startswith("=stop") is True:
            return [True, input_file2]

        # Substitute any symbols into the included filename
        unsubstitutedLine = line
        line = substitute_variables(line)

        try:
            ifStackTop = ifStack[-1]
        except:
            ifStackTop = True
        
        if ifStackTop is True:
            if (line.startswith("=include ")) & (rootLoopController == None):
                include_name = substitute_variables(line[9:].rstrip().lstrip())

                # Check for recursive inclusion
                if include_name in includeStack:
                    log(
                        f"File '{include_name}' recursively included. Stopping."
                    )
                    sys.exit()

                # Not recursive so add include file name to stack
                includeStack.append(include_name)
                dependencies.append(include_name)

                if wantVerbose is True:
                    input_file2.append(
                        "<!--mdpre-embed-start:"
                        + str(embedLevel + 1)
                        + ":"
                        + include_name
                        + "-->"
                    )

                try:
                    with open(include_name, "r") as f:
                        stopIt, include_lines = parse_include(f.readlines())
                except:
                    log(f"File {include_name} missing. Terminating.\n")
                    exit()
                
                for line2 in include_lines:
                    input_file2.append(line2)
                if wantVerbose is True:
                    input_file2.append(
                        "<!--mdpre-embed-stop:"
                        + str(embedLevel + 1)
                        + ":"
                        + include_name
                        + "-->"
                    )
                if stopIt is True:
                    return [stopIt, input_file2, vars]

            elif line.startswith("=def ") is True:
                for var in parse_def(line[5:-1].lstrip()):
                    var_index = find_variable(var[0])
                    if var_index > -1:
                        # Replace the variable with its new definition
                        vars[var_index] = var
                    else:
                        # Add the variable as it's new
                        vars.append(var)
    
                    if wantVerbose is True:
                        varName, varType, varValue = var
                        
                        if var_index > -1:
                            redefined =" (redefined)"
                        else:
                            redefined =""
                            
                        input_file2.append(
                            "<!--mdpre-def:"
                            + varName
                            + ":"
                            + varType
                            + ":"
                            + varValue
                            + redefined
                            + "-->"
                        )

            elif line.startswith("=for ") is True:
                verbosity = handle_for(line[5:-1].lstrip())
                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=endfor") is True:
                verbosity, input_file2 = handle_endfor(line[8:-1].lstrip(), input_file2)
                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif currentLoopController != None:
                # There is an active loop
                if line.startswith("=include "):
                    # Add current line to loop lines - as an include
                    lineController = LoopController("include", None, "", [], unsubstitutedLine, [])
                    currentLoopController.children.append(lineController)
                else:
                    # Add current line to loop lines - as an ordinary line
                    lineController = LoopController("line", None, "", [], unsubstitutedLine, [])
                    currentLoopController.children.append(lineController)

            elif line.startswith("=inc ") is True:
                parse_inc(line)

            elif line.startswith("=dec ") is True:
                parse_dec(line)

            elif line.startswith("=undef") is True:
                varName = line[7:-1].lstrip()
                verbosity = handle_undef(varName)

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifempty ") is True:
                verbosity = handle_ifempty(line[9:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifnotempty ") is True:
                verbosity = handle_ifnotempty(line[12:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifnempty ") is True:
                verbosity = handle_ifnotempty(line[10:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifmatch ") is True:
                verbosity = handle_ifmatch(line[9:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifnotmatch ") is True:
                verbosity = handle_ifnotmatch(line[12:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifnmatch ") is True:
                verbosity = handle_ifnotmatch(line[10:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifdef ") is True:
                verbosity = handle_ifdef(line[7:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=ifndef ") is True:
                verbosity = handle_ifndef(line[8:].lstrip().rstrip())

                if wantVerbose is True:
                    input_file2.append(verbosity)

            elif line.startswith("=endif") is False:
                input_file2.append(line)

        if line.startswith("=endif") is True:
            verbosity = handle_endif()

            if wantVerbose is True:
                input_file2.append(verbosity)

    # Pop this file from the stack
    includeStack.pop()

    embedLevel -= 1
    
    return [False, input_file2]


def replace_varname(varName):
    global vars
    for var in vars:
        if (var[0] == varName) & (var[1] == "T"):
            # A match so return the value
            return var[2]
    return "&" + varName + ";"


def substitute_variables(input_line):
    fragments = input_line.split("&")
    ampersands = len(fragments) - 1

    # Output line starts with fragment before the first ampersand
    output_line = fragments[0]

    # Go through the remaining fragments, extracting their data
    for f in range(ampersands):
        fragment = fragments[f + 1]
        semicolonPos = fragment.find(";")
        if semicolonPos == -1:
            # No terminating semicolon
            output_line += "&" + fragment
        else:
            # Terminating semicolon so extract variable name
            varName = fragment[:semicolonPos]
            tail = fragment[semicolonPos + 1 :]
            output_line += replace_varname(varName) + tail
    return output_line


def handle_linejoins(input_file):
    input_file2 = []
    output_line = ""
    pending = False
    line_count = len(input_file)

    for line_number, line in enumerate(input_file):
        output_line += line

        if line_number < line_count - 1:
            next_line = input_file[line_number + 1]
        else:
            next_line = ""

        if line.endswith("\\\n"):
            # Next line should be concatenated to this one
            output_line = output_line[:-2]
            pending = True

        elif next_line.startswith("<br/>"):
            output_line = output_line[:-1]
            pending = True
            
        else:
            # Next line shouldn't be concatenated to this one
            input_file2.append(output_line)
            output_line = ""
            pending = False
    if pending is True:
        input_file2.append(output_line)

    return input_file2


# Returns one item per potential TOC entry. First is level, Second is Text
def extractTableOfContents(p_input_file_lines, o_heading_symbol="#"):
    r_toc = []  # | init:
    r_minTocLevel = 999
    r_maxTocLevel = 0
    for line in p_input_file_lines:  # | for every line:

        if line.startswith(o_heading_symbol):  # |   if line starts with heading:
            title = line.lstrip(o_heading_symbol)  # |     remoe leading sign
            level = len(line) - len(title)  # |     calculate level
            title = title.lstrip().rstrip()  # |     flatten heading title
            r_toc.append((level, title))  # |     append to list
            # |
            if level > r_maxTocLevel:  # |     maybe update levels
                r_maxTocLevel = level
            elif level < r_minTocLevel:
                r_minTocLevel = level

    return [r_minTocLevel, r_maxTocLevel, r_toc]


def parseTocStatement(line, minTocLevel, maxTocLevel):
    TocParms = line[5:].lstrip().rstrip()
    if TocParms == "":
        # No parms so return defaults - full depth and "Contents"
        return [minTocLevel, maxTocLevel, "Contents"]
    else:
        # Have parms so parse them
        TocParmsArray = TocParms.split(" ")
        if TocParmsArray[0].isdigit() is True:
            # First parm is either max or min level spec
            level1 = int(TocParmsArray[0])
            if len(TocParmsArray) == 1:
                # First parm is only parm so it is the max level
                return [minTocLevel, level1, "Contents"]
            elif TocParmsArray[1].isdigit() is True:
                # Second parm is also a number so have both min and max
                level2 = int(TocParmsArray[1])
                if len(TocParmsArray) == 2:
                    # Have both numeric parms and no title
                    return [level1, level2, "Contents"]
                else:
                    # Have both numeric parms and a title
                    return [level1, level2, TocParms[4:]]
            elif TocParmsArray[1] == "*":
                # Top level limited by levels available
                level2 = maxTocLevel
                if len(TocParmsArray) == 2:
                    # Have both range parms and no title
                    return [level1, level2, "Contents"]
                else:
                    # Have both range parms and a title
                    return [level1, level2, TocParms[4:]]
        elif TocParms != "":
            # Have just the title
            return [minTocLevel, maxTocLevel, TocParms]


def makeLink(linkText):
    linkURL = (
        linkText.replace("-", "")
        .replace(" ", "-")
        .replace("?", "")
        .replace("`", "")
        .replace("=", "")
        .replace(",", "")
        .replace(":", "")
        .replace(".", "")
        .replace("\\", "")
        .replace('"', "")
        .replace("'", "")
        .lower()
        .rstrip("-")
    )
    return re.sub(r"-+", "-", linkURL)


def handle_verbose(line):
    noPrefixSuffix = line[10:-3]
    verboseArray = noPrefixSuffix.split(":")
    verboseType = verboseArray[0]

    if verboseType == "embed-start":
        embedLevel = int(verboseArray[1])
        log(("---" * embedLevel) + "> Start of " + verboseArray[2] + " (@" + str(embedLevel) + ")\n")

    elif verboseType == "embed-stop":
        embedLevel = int(verboseArray[1])
        log(("---" * embedLevel) + "> End of " + verboseArray[2] + " (@" + str(embedLevel) + ")\n")

    elif verboseType == "heading":
        log(line[18:-3].replace("#", "..... ")[6:].lstrip() + "\n")

    elif verboseType == "toc":
        log("Table Of Contents - spec '" + noPrefixSuffix[9:] + "'\n")

    elif verboseType == "csvrule":
        log("CSV rule '" + noPrefixSuffix[17:] + "'\n")
    
    elif verboseType == "csvflow":
        log("CSV row flowing '" + noPrefixSuffix[17:] + "'\n")
    
    elif verboseType == "csv":
        log("CSV Start\n")

    elif verboseType == "endcsv":
        log("CSV Stop\n")

    elif verboseType == "cal":
        log("Calendar Start\n")

    elif verboseType == "endcal":
        log("Calendar Stop\n")

    elif verboseType == "caldays":
        log("Calendar Day Span\n")

    elif verboseType == "calkey":
        log("Calendar Class Days\n")

    elif verboseType == "calnote":
        log("Calendar Days Note\n")

    elif verboseType == "colalign":
        log("Column Alignment - spec '" + noPrefixSuffix[19:] + "'\n")

    elif verboseType == "colwidth":
        log("Column Width - spec '" + noPrefixSuffix[19:] + "'\n")
    
    elif verboseType == "rowspan":
        log("Row span - spec '" + noPrefixSuffix[17:] + "'\n")

    elif verboseType == "def":
        if verboseArray[2] == "T":
            log("Def " + verboseArray[1] + " = " + ":".join(verboseArray[3:]) + "\n")
        else:
            log("Def " + verboseArray[1] + "\n")

    elif verboseType == "undef":
        if verboseArray[1] == "found":
            log("Undef successful " + verboseArray[2] + "\n")
        else:
            log("Undef failed " + verboseArray[2] + "\n")

    elif verboseType == "endif":
        log("Endif\n")

    elif verboseType == "ifdef":
        if verboseArray[1] == "true":
            log("Ifdef true " + verboseArray[2] + "\n")
        else:
            log("Ifdef nottrue " + verboseArray[2] + "\n")

    elif verboseType == "ifndef":
        if verboseArray[1] == "true":
            log("Ifndef true " + verboseArray[2] + "\n")
        else:
            log("Ifndef untrue " + verboseArray[2] + "\n")

    elif verboseType == "ifempty":
        if verboseArray[1] == "true":
            log("IfEmpty true " + verboseArray[2] + "\n")
        else:
            log("IfEmpty nottrue " + verboseArray[2] + "\n")

    elif verboseType == "ifnotempty":
        if verboseArray[1] == "true":
            log("IfNotEmpty true " + verboseArray[2] + "\n")
        else:
            log("IfNotEmpty nottrue " + verboseArray[2] + "\n")

    elif verboseType == "ifmatch":
        if verboseArray[1] == "true":
            log("IfMatch true " + verboseArray[2] + "\n")
        else:
            log("IfMatch nottrue " + verboseArray[2] + "\n")

    elif verboseType == "ifnotmatch":
        if verboseArray[1] == "true":
            log("IfNotMatch true " + verboseArray[2] + "\n")
        else:
            log("IfNotMatch nottrue " + verboseArray[2] + "\n")

    elif verboseType == "for":
        log("For " + verboseArray[1] + "\n")

    elif verboseType == "endfor":
        log("Endfor " + "\n")

    elif verboseType == "exec":
        log("Exec " + verboseArray[1][6:] + "\n")

    else:
        log("Unknown " + line + "\n")

    return


# Handle a -d command line parameter
def handleCommandLineDefine(defString):
    equalsPos = defString.find("=")
    if equalsPos > -1:
        # Assign a value to the variable
        name = defString[:equalsPos]
        value = defString[equalsPos + 1 :]
        parmVars.append("=def " + name + " " + value)
    else:
        # No value to assign so just define it
        name = defString
        parmVars.append("=def " + name)


# Set up standard variables
def setupStandardVariables():
    now = datetime.datetime.now()
    runTime = now.strftime("%H&colon;%M").lstrip()
    runDate = now.strftime("%e %B&comma; %G").lstrip()
    runYear = now.strftime("%G").lstrip()
    runMonth = now.strftime("%B").lstrip()
    runDay = now.strftime("%e").lstrip()

    input_file.insert(0, "=def date " + runDate + " ")
    input_file.insert(0, "=def time " + runTime + " ")

    input_file.insert(0, "=def year " + runYear + " ")
    input_file.insert(0, "=def month " + runMonth + " ")
    input_file.insert(0, "=def day " + runDay + " ")
    
    username = os.getenv('USER') or os.getenv('LOGNAME') or os.getenv('USERNAME')
    input_file.insert(0, "=def userid " + username + " ")
    
    input_file.insert(0, "=def mdpre_level " + mdpre_level + " ")
    input_file.insert(0, "=def mdpre_date " + mdpre_date + " ")


    input_file.insert(0, "=def processor " + platform.processor() + " ")
    input_file.insert(0, "=def python_implementation " + platform.python_implementation() + " ")
    input_file.insert(0, "=def python_version " + platform.python_version() + " ")
    input_file.insert(0, "=def release " + platform.release() + " ")
    input_file.insert(0, "=def system " + platform.system() + " ")
    input_file.insert(0, "=def machine " + platform.machine() + " ")
    arch1, arch2 = platform.architecture()
    if arch2 == "":
        architecture = arch1
    else:
        architecture = arch1 + " " + arch2
    input_file.insert(0, "=def architecture " + architecture + " ")
    input_file.insert(0, "=def version " + platform.version() + " ")
    input_file.insert(0, "=def node " + platform.node() + " ")
    
    # Filenames
    if inputFilename == "":
        input_file.insert(0, "=def input stdin ")
    else:
        input_file.insert(0, "=def input " + inputFilename + " ")
        
    if outputFilename == "":
        input_file.insert(0, "=def output stdout ")
    else:
        input_file.insert(0, "=def output " + outputFilename + " ")
        
    if logFilename == "":
        input_file.insert(0, "=def logfile stderr ")
    else:
        input_file.insert(0, "=def logfile " + logFilename + " ")
        
    if makefileFilename == "":
        try:
            # If this succeeds file descriptor 3 was available to write to
            os.write(3, bytes("", "UTF-8"))
            input_file.insert(0, "=def makefile file-3 ")
        except:
            # Handle the case where file descriptor 3 was not available to write to
            input_file.insert(0, "=def makefile none ")

    else:
        input_file.insert(0, "=def makefile " + makefileFilename + " ")
        

def exit_script(p_output, p_code=0):
    if p_output != None:
        p_output.close()
        if p_code == 0:
            log_status("- Processing completed.")
        elif p_code == 1:
            # HELP output
            p_code = 0
        else:
            log_status(f"- Processing STOPPED with error {p_code}")
    else:
        p_code = 0

    sys.exit(p_code)


def create_output_file(p_file_path=""):
    """
    param: p_file_path:
        "" : use sys.stdout
    """
    r_output = None

    if p_file_path == "":
        r_output = Output(sys.stdout)
    else:
        if Path(p_file_path).exists():
            if wantVerbose:
                log("WARNING: overwriting output Markdown file!")
            pass
        to_file = open(p_file_path, "w")
        r_output = Output(to_file)

    return r_output


############################################################################################################
#  Main
#

BOLD = "\033[1m"
END = "\033[0m"

bannerUnderline = "=" * len(banner)

wantVerbose = False

wantTextBundle = False
wantTextPack = False

textBundleFilename = ""

rootLoopController = None
currentLoopController = None

parmVars = []

g_output = None  # | global variable for writing output

markdownFile = ""

# If any of these remain empty a stream is used
inputFilename = ""
outputFilename = ""
makefileFilename = ""

logFilename = ""

# sys.stderr is the default logging destination
logfileHandle = sys.stderr

def bold(p_text):
    return BOLD + p_text + END

arguments = len(sys.argv) - 1

lastArgument = ""

# First pass argument parsing - just to pick up any log filename
for arg in range(1, arguments + 1):
    argument = sys.argv[arg]

    if argument == "-l":
        if arg > arguments - 1:
            log("-l with no filename parameter. Ignoring")
        else:
            # Parameter after -l is log filename
            logFilename = sys.argv[arg + 1]

            # Nullify filename parameter
            sys.argv[arg + 1] = ""
            
            logfileHandle = open(logFilename, "w")

        # Nullify -l parameter
        sys.argv[arg] = ""

log("\n" + banner + "\n" + bannerUnderline + "\n")

# Second pass argument parsing - to pick up all the rest
for arg in range(1, arguments + 1):
    argument = sys.argv[arg]
    
    if argument == "":
        # Parameters nullified by first pass argument parsing
        pass

    elif argument == "-h":
        # Print help
        log(
            "\n\nThe mdpre program is a Markdown preprocessor, making writing complex\nMarkdown documents easier.\n\n"
        )
        log(
            "\n" + BOLD + "Usage:" + END + "\n\nmdpre < inputfile > outputfile\n\n"
        )
        log("which processes from inputfile to outputfile.\n\n")

        log(BOLD + "or:\n\n" + END)
        log("mdpre -h\n\n")
        log("which generates this help.\n\n")

        log(BOLD + "or:\n\n" + END)
        log("mdpre -v < inputfile > outputfile\n\n")
        log('which writes additional information in "verbose mode".\n\n')

        log(BOLD + "or:\n\n" + END)
        log("mdpre -t < inputfile outputdir\n\n")
        log(
            "which creates a textbundle directory from inputfile. -v can be used with -t.\n\n"
        )

        log(BOLD + "or:\n\n" + END)
        log("mdpre -z < inputfile outputfile\n\n")
        log(
            "which creates a textpack (zipped textbundle) file from inputfile. -v can be used with -z.\n\n"
        )

        log(BOLD + "Logging:\n\n" + END)
        log(BOLD + "--------\n\n" + END)
        log("Add 2>logfileName to get logging.\n\n")

        log(BOLD + "Make File Fragments:\n\n" + END)
        log(BOLD + "--------------------\n\n" + END)
        log("Add 3>makefile to get make file dependencies written to a file.\n\n")

        log("\n\n" + BOLD + "Variables\n\n" + END)
        log(BOLD + "---------\n\n" + END)
        log(
            "\nYou can define a variable without a value with the -d flag:\n\n"
        )
        log("mdpre -dfred < inputfile outputfile\n\n")
        log(
            "You can define a variable with a value also with the -d flag:\n\n"
        )
        log("mdpre '-djon=bon jovi' < inputfile outputfile\n\n")
        log(
            "In this case quotes were used to allow a variable to take a value with spaces in.\n\n"
        )

        log("\n\n" + BOLD + "Process As A CSV File\n\n" + END)
        log(BOLD + "---------------------\n\n" + END)
        log(
            "\nmdpre can treat the whole input file as a CSV file, creating a Markdown table from it, if you specify the -c flag:\n\n"
        )
        log("mdpre -c < input.csv outputfile\n\n")

        exit_script(g_output, 1)

    elif argument == "-v":
        # Turn on "verbose mode"
        wantVerbose = True

    elif argument == "-t":
        wantTextBundle = True
        wantTextPack = False

    elif argument == "-z":
        wantTextBundle = True
        wantTextPack = True

    elif argument[:2] == "-d":
        handleCommandLineDefine(argument[2:])

    elif argument == "-c":
        g_wrapInCSV = True

    elif lastArgument in ["-t", "-z"]:
        if textBundleFilename == "":
            textBundleFilename = argument
        else:
            textBundleFilename = textBundleFilename + " " + argument

        lastArgument = ""

    elif lastArgument == "-i":
        # This argument is the input filename
        inputFilename = argument

    elif lastArgument == "-o":
        # This argument is the output filename
        outputFilename = argument

    elif lastArgument == "-m":
        # This argument is the makefile fragment filename
        makefileFilename = argument

    lastArgument = argument

# Preliminaries if creating a textbundle
if textBundleFilename != "":
    realpath = os.path.realpath(textBundleFilename)
    if wantTextPack is True:
        zippath = realpath
        realpath = realpath + "-temp"

    if wantVerbose is True:
        log("Writing to Textbundle " + realpath + "\n\n")

    # Check if path exists as a directory
    if os.path.exists(realpath):
        if os.path.isfile(realpath) is True:
            # Regular file of that name exists so quitting
            log(realpath + " is a regular file. Quitting.\n")
            sys.exit(0)
        else:
            # Directory already exists
            if wantVerbose is True:
                log(
                    "Directory exists so not creating. It might already have files, some of which might be overwritten.\n\n"
                )
    else:
        # Directory doesn't exist so create it
        if wantVerbose is True:
            log("Directory does not exist - so creating.\n\n")
        os.mkdir(realpath)

    # Check if assets path exists
    assets = realpath + "/assets"
    if os.path.exists(assets):
        if wantVerbose is True:
            log("assets directory exists so not creating.\n\n")
    else:
        if wantVerbose is True:
            log("Creating assets directory.\n\n")
        os.mkdir(assets)

    # Add info.json file
    infoJSON = open(realpath + "/info.json", "w")
    infoJSON.write("{\n")
    infoJSON.write(' "version": 2\n')
    # infoJSON.write(' "type": "net.daringfireball.markdown"\n')

    infoJSON.write("}\n")
    infoJSON.close()

    markdownFile = realpath + "/text.markdown"

    # Remove any prior instance of the markdown file
    if os.path.isfile(markdownFile) is True:
        os.remove(markdownFile)
        # | ## Textbundle:
    g_output = create_output_file(
        markdownFile
    )  # | Open the file where markdown goes for write

elif markdownFile != "":

    if os.path.isfile(markdownFile) is True:
        os.remove(markdownFile)
        # | ## File:
    g_output = create_output_file(
        markdownFile
    )  # | Open the file where markdown goes for write

else:  # | ## stdout
    g_output = (
        create_output_file(outputFilename)
    )

if inputFilename == "":
    input_file = sys.stdin.readlines()
else:
    if os.path.isfile(inputFilename) is True:
        with open(inputFilename, "r") as file_handle:
            input_file = file_handle.readlines()


# If -c was specified on the command line wrap the file with =csv / =endcsv bracket
if g_wrapInCSV == True:
    input_file.insert(0, "=csv")
    input_file.append("=endcsv")

# Add any command line defines to the front
for parmVar in parmVars:
    input_file.insert(0, parmVar + " ")

# insert standard variables at the front
setupStandardVariables()


ifStack = [True]

# Prime list of dependencies
dependencies = []

# Regexes for matching graphics etc - to detect dependencies
graphicRE = r"!\[(.*?)\]\((.+?)\)"
graphicRegex = re.compile(graphicRE)

clickableGraphicRE = r"\[" + graphicRE + r"\]\((.+?)\)"
clickableGraphicRegex = re.compile(clickableGraphicRE)

videoRE = "<video (.*?)></video>"
videoRegex = re.compile(videoRE)

audioRE = "<audio (.*?)></audio>"
audioRegex = re.compile(audioRE)


# Prime list of referenced files
includeStack = ["top-level-file"]

embedLevel = 0

vars = []
# Pre-process - to pick up includes
stopIt, input_file = parse_include(input_file)

# Handle line joining
input_file = handle_linejoins(input_file)

# Generate Table Of Contents - even if it's not needed
minTocLevel, maxTocLevel, tableOfContents = extractTableOfContents(input_file)

# Do any other processing, such as CSV to table
CSV_colaligns = []
CSV_colwidths = []
CSV_rules =  []
in_csv = False
in_cal = False


for line in input_file:
    line = line.rstrip("\n")
    if line.startswith("<!--mdpre-"):
        # For verbose mode writing to stderr
        handle_verbose(line)

    elif line.startswith("#"):
        if wantVerbose is True:
            handle_verbose("<!--mdpre-heading:" + line + "-->")
        g_output.write(line)

    elif line.startswith("=toc"):
        if wantVerbose is True:
            handle_verbose("<!--mdpre-toc:" + line + "-->")
        minLevel, maxLevel, heading = parseTocStatement(line, minTocLevel, maxTocLevel)
        print(minLevel, maxLevel, heading, file = logfileHandle)
        g_output.printTableOfContents(
            minLevel, maxLevel, "### " + heading, tableOfContents
        )

    elif line.startswith("=csvrule"):
        CSV_rules = handle_CSVrule(CSV_rules, line[9:])
        
        if wantVerbose is True:
            handle_verbose("<!--mdpre-csvrule:" + line + "-->")

    elif line.startswith("=csvflow"):
        CSV_flowLines, CSV_flowGutterCells = handle_CSVflow(line[9:])
        
        if wantVerbose is True:
            handle_verbose("<!--mdpre-csvflow:" + line + "-->")

    elif (line.startswith("=csv")) & (in_csv is False):
        csvWords = line.split(" ")
        if len(csvWords) > 1:
            csvDialectWord = csvWords[1]
            csvDialects = csv.list_dialects()
            availableDialects = ", ".join(csvDialects)
            if csvDialectWord in csvDialects:
                csvDialect = csvDialectWord
            else:
                log(f"Unavailable CSV dialect specified - {csvDialectWord}. Using default.")
                log(f"Available dialects are: {availableDialects}")
                csvDialect = ""
        else:
            csvDialect = ""

        in_csv = True
        in_rowspan = False
        CSV_lines = []

        if wantVerbose is True:
            handle_verbose("<!--mdpre-csv:" + line + "-->")

    elif (line.startswith("=endcsv")) & (in_csv is True):
        g_output.formatCSV(CSV_lines, CSV_colaligns, CSV_colwidths, CSV_rules, CSV_flowLines, CSV_flowGutterCells)
        in_csv = False
        if wantVerbose is True:
            handle_verbose("<!--mdpre-endcsv:" + line + "-->")


    elif line.startswith("=colalign "):
        CSV_colaligns = parse_colalign(line[10:])
        if wantVerbose is True:
            handle_verbose("<!--mdpre-colalign:" + line + "-->")

    elif line.startswith("=colwidth "):
        CSV_colwidths = parse_colwidth(line[10:])
        if wantVerbose is True:
            handle_verbose("<!--mdpre-colwidth:" + line + "-->")

    elif line.startswith("=rowspan"):
        in_rowspan = True
        if wantVerbose is True:
            handle_verbose("<!--mdpre-rowspan:" + line + "-->")
            rowspan = line.rstrip()

    elif in_csv is True:
        if in_rowspan:
            # Prepend line with rowspan
            CSV_lines.append(rowspan + "!!XYZZY!!" + line)
            in_rowspan = False
        else:
            # Don't prepend line with rowspan
            CSV_lines.append(line)

    elif (line.startswith("=cal ")) & (in_cal is False):
        in_cal = True
        cal_lines = []
        cal_spans = {}
        cal_keys = {}
        cal_notes = {}
        cal_date = parse_calstart(line[5:])
        if wantVerbose is True:
            handle_verbose("<!--mdpre-cal:" + line + "-->")

    elif (line.startswith("=endcal")) & (in_cal is True):
        g_output.formatCalendar(cal_lines, cal_date, cal_spans, cal_keys, cal_notes)
        in_cal = False
        if wantVerbose is True:
            handle_verbose("<!--mdpre-endcal:" + line + "-->")

    elif (line.startswith("=caldays")) & (in_cal is True):
        cal_spans = parse_caldays(line[9:], cal_spans)
        if wantVerbose is True:
            handle_verbose("<!--mdpre-caldays:" + line + "-->")

    elif (line.startswith("=calkey")) & (in_cal is True):
        cal_keys = parse_calkeys(line[8:], cal_keys)
        if wantVerbose is True:
            handle_verbose("<!--mdpre-calkey:" + line + "-->")

    elif (line.startswith("=calnote")) & (in_cal is True):
        cal_notes = parse_calnote(line[9:], cal_notes)
        if wantVerbose is True:
            handle_verbose("<!--mdpre-calnote:" + line + "-->")

    elif in_cal is True:
        cal_lines.append(line)

    elif line.find("![") > -1:
        if (line[0:4] != "    ") & (line[0:1] != "\t"):
            # Match is not in a code block
            dependencies += getResourceNames(line)
        
        if(wantTextBundle is True):
            # Fix up graphics references and copy graphics to assets folder
            g_output.handle_adjustGraphics(line)
        else:
            g_output.write(line)

    else:
        g_output.write(line)

# NOTE: toFile.close() is handled in the new exits function
# NOTE: ! this message will self destruct during the pull request

# Issue a warning if 1 or more =endif statements are missing
if (l := len(ifStack)) > 1:
    if l == 2:
        log(f'Warning 1 =endif statement missing.')
    else:
        log(f'Warning {str(l - 1)} =endif statements missing.')

# Optionally zip into TextPack format
if wantTextPack is True:
    if wantVerbose is True:
        print("Archiving " + realpath + " to " + zippath + ".zip")
    shutil.make_archive(zippath, "zip", realpath)

    if wantVerbose is True:
        print("Renaming " + zippath + ".zip to " + zippath)
    os.rename(zippath + ".zip", zippath)

    if wantVerbose is True:
        print("Removing temporary files in directory " + realpath)
    shutil.rmtree(realpath)

makefile = "makefragment=\n"
makefile += "$(target).md: \\\n"
makefile += "\t$(target).mdp \\\n"
# 
dependencyCount = len(dependencies)

for dnum, d in enumerate(dependencies):
    makefile += f"\t{d.replace(" ", "\\ ")}"
    if dnum < dependencyCount - 1:
        makefile += " \\\n"
    else:
        makefile += " \n\n"

makefile += "\tmdpre -v < $(target).mdp > $(target).md 2>$(target).log $(makefragment)\n"

if makefileFilename != "":
    # Write the make file fragment to the file specified
    if Path(makefileFilename).exists():
        if wantVerbose:
            log("WARNING: overwriting output makefile fragment file!")
        pass

    with open(makefileFilename, "w") as m:
        m.write(makefile)
    
else:
    # Try to write the make file insert to File Descriptor 3
    try:
        os.write(3, bytes(makefile,"UTF-8"))
    except:
        pass

exit_script(g_output, 0)
